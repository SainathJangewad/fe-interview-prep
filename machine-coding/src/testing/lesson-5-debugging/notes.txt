Hereâ€™s a **short and focused guide** to DOM debugging during tests:
---

## âœ… 1. `screen.debug()` â€” Print the current DOM

Use this to see what the virtual DOM looks like at any point:

import { render, screen } from '@testing-library/react';
import MyForm from './MyForm';

test('renders form', () => {
  render(<MyForm />);
  
  screen.debug(); // ðŸ‘ˆ prints the entire virtual DOM

  const input = screen.getByLabelText(/name/i);
  expect(input).toBeInTheDocument();
});

You can also log a **specific element**:

const input = screen.getByLabelText(/name/i);
screen.debug(input); // prints just that element
---

## âœ… 2. `logRoles()` â€” Print all accessible roles

Helpful when you can't figure out how to query an element:

import { render, screen, logRoles } from '@testing-library/react';
import MyForm from './MyForm';

test('check roles', () => {
  const { container } = render(<MyForm />);
  logRoles(container); // ðŸ‘ˆ shows available roles
});
---

## âœ… 3. `debugger` with DOM inspection

You can pause test execution and inspect the DOM manually:

import { render, screen } from '@testing-library/react';
import MyForm from './MyForm';

test('pause test', () => {
  render(<MyForm />);
  debugger; // ðŸ‘ˆ pause and inspect in DevTools
  const btn = screen.getByRole('button', { name: /submit/i });
  expect(btn).toBeDisabled();
});

Then run with a debugger attached (in VS Code or Chrome DevTools).
---

## âœ… 4. Useful tips

### Run a single test with `it.only`:

it.only('debug this test', () => {
  ...
});

### Show DOM before/after user events:

userEvent.click(screen.getByRole('button', { name: /show form/i }));
screen.debug(); // to see updated DOM
-----------------------------------