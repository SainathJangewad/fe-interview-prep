
## ğŸ§  Lesson: Type Assertions in TypeScript

### âœ… What is a Type Assertion?

TypeScript lets you **override its type inference** when **you know more** about the value than TypeScript does.
const val = someValue as string;
```

Youâ€™re telling TypeScript:

> â€œTrust me â€” this is a string.â€

---

## ğŸ’¡ Why do we use assertions?

1. When **TS canâ€™t infer** the right type.
2. To **avoid strict type errors**.
3. To help when using **DOM APIs**, **refs**, or **external libraries**.

---

## ğŸ›  Common Real-World Examples in React

---

### 1. **Asserting DOM Elements**
const el = document.getElementById("myDiv") as HTMLElement;
el.style.backgroundColor = "blue";
```

ğŸ” Why?
Because `getElementById()` returns `HTMLElement | null`, so you must assert to safely access `.style`.

---

### 2. **With React Refs**
const inputRef = useRef<HTMLInputElement>(null);

useEffect(() => {
  inputRef.current?.focus();
}, []);
```

OR when you use non-null assertion:
inputRef.current!.focus(); // "Iâ€™m sure itâ€™s not null"
```

ğŸ” Why?
`ref.current` is possibly `null`, and TS complains.
The `!` tells TS: "Don't worry, it's there."
---

### 4. **Custom Types from JSON**
const data = JSON.parse(jsonString) as MyType;
```

ğŸ” Why?

Because `JSON.parse()` returns `any`, and you assert to add proper type safety.

---

### 5. **Forced Narrowing**
type Animal = { type: "cat"; meow: () => void } | { type: "dog"; bark: () => void };

const pet = getPet();
(pet as { type: "dog"; bark: () => void }).bark();
```

ğŸ” Why?
You narrow down the union type when youâ€™re **sure** what variant it is.

---

## âš ï¸ Be Careful!

* **Donâ€™t use assertions blindly.**
* Youâ€™re skipping TS safety checks.
* If youâ€™re wrong, it crashes at runtime.

---

## âœ… Safer Alternatives

Instead of:
const el = document.getElementById("id") as HTMLElement;
```

Do:
const el = document.getElementById("id");
if (el instanceof HTMLElement) {
  el.style.color = "red";
}
--------------------------------------------
Conditionally narrow a union type

type User = { type: "user"; username: string };
type Admin = { type: "admin"; accessLevel: number };
type Person = User | Admin;

const person: Person = getPerson();

if (person.type === "admin") {
  console.log((person as Admin).accessLevel);
}

âš ï¸ Warning
Type assertions do not perform type checking at runtime. You are telling TypeScript: â€œTrust me, I know what Iâ€™m doing.â€
---------------------------

