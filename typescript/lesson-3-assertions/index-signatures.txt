#### ğŸ“Œ What is it?

Allows defining object types with **unknown property names**, but known key/value types.
type Scores = {
  [key: string]: number;
};

const marks: Scores = {
  math: 90,
  english: 85,
};

---

### âœ… When to Use in React?

#### 1. **Form Errors**
type FormErrors = { [field: string]: string };

const errors = {
  name: "Required",
  email: "Invalid",
};

#### 2. **Dynamic Form Data**
type FormData = { [field: string]: string | number };

#### 3. **API Data / Flags**
type Flags = { [flag: string]: boolean };

### âš ï¸ Note

* Use when keys are **dynamic**
* No typo protection â€” use only when flexibility is needed

-------------------------------------------------------
### ğŸ”¹ What is `keyof`?

It gives you the **keys of a type** as a union.
type Person = { name: string; age: number };
type Keys = keyof Person; // "name" | "age"

---

### ğŸ”¹ What is `keyof` assertion?

Itâ€™s used like this:
function getValue<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

This **asse** that `key` is a valid key of object `T`.

---

### ğŸ”¹ React example:
type FormData = { email: string; password: string };

function handleChange<K extends keyof FormData>(key: K, value: FormData[K]) {
  // safe: key must be "email" or "password"
}

---

### ğŸ”¹ Why use it?

âœ… Preve invalid keys
âœ… Enables type-safe dynamic access
âœ… Useful in generic utilities

------------------------
