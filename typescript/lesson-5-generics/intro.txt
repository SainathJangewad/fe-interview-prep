## âœ… What Are Generics?

**Generics** let you write **reusable code** that works with different **types**, like a function or component that can handle multiple data types **safely**.
---

## ğŸ”¶ Why React Devs Use Generics?

* For reusable components
* For reusable hooks
* For API functions
* To avoid `any` while keeping flexibility
---

## ğŸ”· 1. Generic Function

function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(10); // T = number
const str = identity("hello");    // T = string (inferred)
---

## ğŸ”· 2. Generic React Component

type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map(renderItem)}</ul>;
}

// Usage
<List
  items={["apple", "banana"]}
  renderItem={(item) => <li key={item}>{item}</li>}
/>

âœ… **Why this is asked**: Shows understanding of reusable typed components.

---

## ğŸ”· 3. Generic Hook

function useArray<T>(initial: T[]) {
  const [array, setArray] = React.useState<T[]>(initial);
  const push = (item: T) => setArray((a) => [...a, item]);
  return { array, push };
}

// Usage
const { array, push } = useArray<number>([1, 2, 3]);

âœ… **Interview Tip**: Hooks with generics show abstraction skill.

---

## ğŸ”· 4. Generic API Response Wrapper

type ApiResponse<T> = {
  data: T;
  success: boolean;
  error?: string;
};

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  const res = await fetch(url);
  const data = await res.json();
  return { data, success: true };
}

// Usage
type User = { name: string; age: number };

const res = await fetchData<User>("/api/user");
```

âœ… **Why this is asked**: Shows knowledge of strongly-typed APIs.

---

## ğŸ”· 5. React.forwardRef with Generics
x
const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  (props, ref) => <input ref={ref} {...props} />
);
```

âœ… **Why this matters**: You use generics to type refs correctly.

---

## ğŸ§  Common Interview Qs on Generics

1. **Why use generics over `any`?**

   * `any` disables type checking. Generics give flexibility **with** safety.

2. **How does Type Inference work with generics?**

   * TypeScript often infers the type, but you can manually specify it too.

3. **Where are generics used in React libraries?**

   * `useState<T>()`, `useRef<T>()`, React Query, Form libraries, etc.

---

## âœ… Summary Cheat Sheet

| Use Case    | Example                   |
| ----------- | ------------------------- |
| Reusable fn | `function<T>(value: T)`   |
| List comp   | `<List<T> items={...} />` |
| API wrapper | `fetchData<T>()`          |
| Custom hook | `useArray<T>()`           |
| forwardRef  | `React.forwardRef<T>()`   |

-----------------------------------------------------
To create a **generic function** in TypeScript:

---

## âœ… Syntax:

function functionName<T>(arg: T): T {
  return arg;
}
```

* `T` is a **type placeholder** (can be any name, but `T`, `U`, `K` are common).
* It means: â€œThis function will work with any type `T`, and return the same type.â€

---

## ğŸ”¹ Example 1: Identity Function

function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(10);  // T = number
const str = identity("hello");     // T = string (inferred)
```

---

## ğŸ”¹ Example 2: Generic Function with Array

function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const first = firstElement<string>(["a", "b", "c"]); // "a"
```

---

## ğŸ”¹ Example 3: Constraint with `extends`

function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}

getLength("hello");           // valid
getLength([1, 2, 3]);         // valid
// getLength(10);             // âŒ Error: number doesn't have 'length'
```

---

## ğŸ”¹ Example 4: Multiple Generics

function merge<A, B>(a: A, b: B): A & B {
  return { ...a, ...b };
}

const result = merge({ name: "Alice" }, { age: 25 });
// result: { name: "Alice", age: 25 }
```---------------
Sure! Letâ€™s now look at **generic interfaces** in TypeScript â€” another **important interview topic**.

---

## âœ… What is a Generic Interface?

A **generic interface** lets you define an interface with **type parameters** (like `T`), so it can work with **different types**.
---

## ğŸ”¹ Syntax interface InterfaceName<T> {
  property: T;
}
---

## ğŸ”· Example 1: Generic Data Holderinterface Box<T> {
  value: T;
}

const numberBox: Box<number> = { value: 100 };
const stringBox: Box<string> = { value: "hello" };
```
âœ… `Box<T>` can store any type â€” that's the power of generics.

---

## ğŸ”· Example 2: Generic with Multiple Types

interface Pair<K, V> {
  key: K;
  value: V;
}

const item: Pair<string, number> = {
  key: "price",
  value: 999
};
---

## ğŸ”· Example 3: Constrained Generics T extends {length:numner} means u can pass value of any type (T) but this passed type must have the "length" property.

interface Lengthwise<T extends { length: number }> {
  item: T;
}

const valid: Lengthwise<string> = { item: "test" }; // âœ…
const alsoValid: Lengthwise<number[]> = { item: [1, 2, 3] }; // âœ…
// const invalid: Lengthwise<number> = { item: 123 }; // âŒ Error - cuz number does not have 'length' property

---

## ğŸ”· Example 4: Interface with Generic Method interface Logger {
  log<T>(value: T): void;
}

const consoleLogger: Logger = {
  log: (value) => console.log(value),
};

consoleLogger.log("hello");
consoleLogger.log(123);

Q-> here we usually do something like this interface Logger {
  log:(value: T)=>void;
} we cant' do like this?

### ğŸ“Œ Short Note: Generic Function vs Generic Interface in TS

#### âœ… Generic Method (Flexible per call)interface Logger {
  log<T>(value: T): void;
}
```

* Each call to `log()` can use a different type.
* Example: `log("hello")`, `log(123)` â€” both work.

#### âœ… Generic Interface (Fixed type)interface Logger<T> {
  log: (value: T) => void;
}
```

* Type `T` is fixed when the interface is used.
* Example: `Logger<string>` â†’ `log("hi")` âœ…, `log(123)` âŒ

#### âŒ Invalid (Missing generic declaration) interface Logger {
  log: (value: T) => void; // âŒ Error: 'T' not declared
}

âœ” Use **generic method** for flexibility
âœ” Use **generic interface** when the type is known ahead

âœ… Generic methods can be inside non-generic interfaces too.

---

## âœ… Interview Tip

| Asked As                       | You Can Say                                                                   |
| ------------------------------ | ----------------------------------------------------------------------------- |
| â€œWhat are generic interfaces?â€ | â€œInterfaces that take type parameters, allowing flexibility and reusability.â€ |
| â€œWhere are they used?â€         | â€œFor typing APIs, props, utility types, or reusable components.â€              |

------------------------------------------------------------

Great! Letâ€™s now learn how **generics work with classes in TypeScript** â€” another key interview topic.

## âœ… What Are Generic Classes?

A **generic class** is a class that works with **different data types** without losing **type safety**.

---

## ğŸ”· Syntax

class ClassName<T> {
  value: T;
  constructor(val: T) {
    this.value = val;
  }

  getValue(): T {
    return this.value;
  }
}
```

* `T` is a **type placeholder**.
* When you create an object, you pass a real type like `number`, `string`, etc.

---

## ğŸ”¶ Example 1: Generic Box

class Box<T> {
  content: T;
  constructor(value: T) {
    this.content = value;
  }

  getContent(): T {
    return this.content;
  }
}

// Usage:
const numberBox = new Box<number>(123);
const stringBox = new Box<string>("hello");

numberBox.getContent(); // returns number
stringBox.getContent(); // returns string
```

âœ… The type `T` is locked when the object is created.
----------
âœ… Constraining `T` ensures we only allow types with a `.length` property.

---

## âœ… Summary

| Concept             | Meaning                              |
| ------------------- | ------------------------------------ |
| `class<T>`          | A class that works with any type `T` |
| `new Class<Type>()` | Fixes the generic to a real type     |
| `extends`           | Adds constraints to generic types    |
---------------------------------------------------------------------------------------------------------
Absolutely! Letâ€™s focus on **generic constraints** â€” a crucial concept in TypeScript when using generics.

---

## âœ… What is a Generic Constraint?

A **generic constraint** restricts the type that can be passed to a generic.

> Without constraints, `T` can be **anything**.
> With `T extends SomeType`, you're saying â€œT must be like SomeTypeâ€.

---

## ğŸ”· Example 1: Constraint with `length` property

```ts
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}

getLength("hello");     // âœ… string has length
getLength([1, 2, 3]);   // âœ… array has length
// getLength(123);      // âŒ Error: number doesn't have length
```

âœ… We're saying: only allow types that have a `length` property.

---

## ğŸ”· Example 2: Constraint to a specific object shape

interface Person {
  name: string;
  age: number;
}

function greet<T extends Person>(user: T): string {
  return `Hello, ${user.name}`;
}

greet({ name: "Alice", age: 30 });  // âœ…
// greet({ name: "Bob" });          // âŒ age is missing
```

âœ… Here `T` must be **at least** a `Person`.
---

## ğŸ”· Example 3: Constraining to union of types

function printId<T extends string | number>(id: T) {
  console.log(id);
}

printId("abc");  // âœ…
printId(123);    // âœ…
printId(true);   // âŒ not allowed
```

âœ… `T` must be either `string` or `number`.

---

## ğŸ”· Example 4: Generic Constraint with `keyof`

function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const user = { name: "Alice", age: 25 };

getProperty(user, "name"); // âœ…
getProperty(user, "age");  // âœ…
// getProperty(user, "email"); // âŒ Error: "email" is not a key of user
```

âœ… This ensures the key passed is **valid for the given object**.

## ğŸ§  Summary

| Syntax               | Meaning                                    |                                   |
| -------------------- | ------------------------------------------ | --------------------------------- |
| `T extends SomeType` | T must have at least the shape of SomeType |                                   |
| \`T extends string   | number\`                                   | T must be either string or number |
| `K extends keyof T`  | K must be a valid key of T                 |                                   |
-----------------------------------------------------------------------------------------
Great! Letâ€™s dive into **conditional types** in TypeScript, especially **inside generics**, which are often asked in advanced interviews.

---

## âœ… What Are Conditional Types?

A **conditional type** works like an `if-else` in the type system:

T extends U ? X : Y
```

> If type `T` extends type `U`, then use type `X`, otherwise use `Y`.

---

## ğŸ”· Basic Example

```ts
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<string>; // "yes"
type B = IsString<number>; // "no"
---

## ğŸ”· Conditional Type in a Generic Function

```ts
function process<T>(value: T): T extends string ? string[] : T[] {
  if (typeof value === "string") {
    return value.split("") as any;
  }
  return [value] as any;
}

const a = process("abc"); // string[]
const b = process(123);   // number[]
```

âœ… Based on `T`, the return type changes. Useful for building dynamic utilities.

---

## ğŸ”· Use Case: Remove `null` or `undefined`

type NonNullable<T> = T extends null | undefined ? never : T;

type A = NonNullable<string | null>; // string
type B = NonNullable<number | undefined>; // number
```

âœ… Removes null and undefined from a type. This is built-in in TypeScript.

---

## ğŸ”· Use Case: Extract Return Type

type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type Fn = () => number;
type Result = MyReturnType<Fn>; // number
```

âœ… `infer` keyword lets you grab the return type (`R`) from a function.

---

## ğŸ”· Use Case: Conditional Props in React

```ts
type ButtonProps<T extends "link" | "button"> = T extends "link"
  ? { href: string }
  : { onClick: () => void };

// Usage:
const linkBtn: ButtonProps<"link"> = { href: "/home" };
const normalBtn: ButtonProps<"button"> = { onClick: () => {} };
```

âœ… You can make props **change shape** based on a generic type.

---

## âœ… Summary Table

| Concept           | Syntax Example                               |                         |
| ----------------- | -------------------------------------------- | ----------------------- |
| Basic condition   | `T extends U ? X : Y`                        |                         |
| Infer return type | `T extends (...args) => infer R ? R : never` |                         |
| Remove null       | \`T extends null                             | undefined ? never : T\` |
| Use with props    | `T extends "type1" ? Props1 : Props2`        |                         |

-------------------
 